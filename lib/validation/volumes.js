/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright 2020 Joyent, Inc.
 */

var assert = require('assert-plus');
var restify = require('restify');

/*
 * Volume name search param is special because we allow '*' as a prefix or
 * suffix for wildcard searching. As such, we need to validate that the name is
 * valid whether or not it is surrounded by '*'s.
 */
var VALID_VOLUME_NAME_SEARCH_PARAM_REGEXP = /^\*?[\w.-]+\*?$/i;
var VALID_VOLUME_NAME_REGEXP = /^[a-z0-9][\w.-]+$/i;
var VALID_VOLUME_SIZE_REGEXP = /^[1-9][0-9]*$/;
var VALID_VOLUME_TYPES = ['tritonnfs'];
var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

function validateVolumeId(volumeId) {
    var errs = [];

    if (!UUID_RE.test(volumeId)) {
        errs.push(new Error('Invalid volume ID: ' + volumeId + '. Volume ' +
            'ID should match ' + UUID_RE));
    }

    return errs;
}

function validateVolumeName(volumeName) {
    var errs = [];

    /*
     * The limit was chosen so that:
     *
     * 1. it's reasonably close to the limit that docker uses for named volumes
     *    (it seems like it uses the maximum file path length, which according
     *    to POSIX at
     *    http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html
     *    is 256)
     *
     * 2. it's long enough to allow volume names generated by tools such as
     *    docker-compose (which include a "project name" as a way to namespace
     *    resources) to work
     *
     * 3. It's short enough to constrain the amount of resources used when
     *    processing and storing volume names
     */
    var MAX_VOLUME_NAME_LENGTH = 256;

    if (typeof (volumeName) !== 'string') {
        errs.push(new Error('Invalid volume name: volume name must be a ' +
            'string'));
    }

    if (!VALID_VOLUME_NAME_REGEXP.test(volumeName)) {
        errs.push(new Error('Invalid volume name: ' + volumeName +
            '. Volume name should match ' + VALID_VOLUME_NAME_REGEXP));
    }

    if (volumeName && volumeName.length > MAX_VOLUME_NAME_LENGTH) {
        errs.push(new Error('Invalid volume name length: volume name ' +
            'must be at most ' + MAX_VOLUME_NAME_LENGTH + ' long'));
    }

    return errs;
}

function validateVolumeNameSearchParam(name) {
    var errs = [];

    if (!VALID_VOLUME_NAME_SEARCH_PARAM_REGEXP.test(name)) {
        errs.push(new Error('invalid value for name search parameter'));
    }

    return errs;
}

function validateVolumeType(volumeType) {
    var errs = [];
    var validVolumeType = typeof (volumeType) === 'string' &&
        VALID_VOLUME_TYPES.indexOf(volumeType) !== -1;

    if (!validVolumeType) {
        errs.push(new Error('Invalid volume type: ' + volumeType + '. Volume ' +
            'type should be one of: ' + VALID_VOLUME_TYPES.join(', ')));
    }

    return errs;
}

function validateVolumeSize(volumeSize) {
    var errs = [];
    var validVolumeSize = typeof (volumeSize) === 'number' && volumeSize > 0;

    if (!validVolumeSize) {
        errs.push(new Error('Invalid volume size: ' + volumeSize));
    }

    return errs;
}

// NOTE: This duplicates code from sdc-volapi's lib/validation/volumes.js and
//       should probably eventually be put in a library shared between the two.
function validateVolumeSizeSearchParam(size) {
    var errs = [];

    assert.optionalString(size, 'size');

    if (!VALID_VOLUME_SIZE_REGEXP.test(size)) {
        errs.push(new Error('invalid value for size search parameter, must ' +
            'match ' + VALID_VOLUME_SIZE_REGEXP.toString()));
    }

    return errs;
}

function validateVolumeNetwork(volumeNetwork) {
    var errs = [];

    if (!UUID_RE.test(volumeNetwork)) {
        errs.push(new Error('Invalid volume network: ' + volumeNetwork));
    }

    return errs;
}

function validateVolumeNetworks(volumeNetworks) {
    var errs = [];
    var volumeNetworksValid = false;

    if (volumeNetworks !== undefined) {
        if (!Array.isArray(volumeNetworks)) {
            errs.push(new Error('Invalid networks: networks must be an array'));
        } else {
            volumeNetworksValid =
                volumeNetworks.every(function checkNetworkValidity(network) {
                    return validateVolumeNetwork(network).length === 0;
                });

            if (!volumeNetworksValid) {
                errs.push(new Error('Invalid networks: ' + volumeNetworks));
            }
        }
    }

    return errs;
}

function validateAffinityEntry(entry) {
    return typeof (entry) === 'string';
}

function validateAffinity(affinity) {
    var errs = [];

    if (affinity) {
        if (!Array.isArray(affinity) ||
                !affinity.every(validateAffinityEntry)) {
            errs.push(new Error(
                    'Invalid affinity: affinity must be an array of strings'));
        }
    }

    return errs;
}

function validateTags(tags) {
    var errs = [];

    function tagKeyValueAreStrings(key) {
        return typeof (key) === 'string' && typeof (tags[key]) === 'string';
    }

    if (tags) {
        if (typeof (tags) !== 'object' ||
                !Object.keys(tags).every(tagKeyValueAreStrings)) {
            errs.push(new Error(
                'Invalid tags: tags must be an object of key/value strings'));
        }
    }

    return errs;
}

function validateVolumeState(state) {
    var errs = [];
    var VALID_STATES = ['creating', 'ready', 'failed', 'deleting'];

    if (VALID_STATES.indexOf(state) === -1) {
        errs.push(new Error('Volume state: ' + state + ' is invalid'));
    }

    return errs;
}

module.exports = {
    validateAffinity: validateAffinity,
    validateTags: validateTags,
    validateVolumeId: validateVolumeId,
    validateVolumeName: validateVolumeName,
    validateVolumeNameSearchParam: validateVolumeNameSearchParam,
    validateVolumeNetwork: validateVolumeNetwork,
    validateVolumeNetworks: validateVolumeNetworks,
    validateVolumeSize: validateVolumeSize,
    validateVolumeSizeSearchParam: validateVolumeSizeSearchParam,
    validateVolumeState: validateVolumeState,
    validateVolumeType: validateVolumeType
};
