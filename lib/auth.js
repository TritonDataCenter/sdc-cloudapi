/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright 2020 Joyent, Inc.
 */

/*
 * This file defines all the CloudAPI authentication functions,
 * including the following authentication methods:
 *
 * - HTTP Signature Auth (signatureAuth): both, direct or using token-auth
 *   through 3rd party applications.
 *   Versions 0.9.x and 0.10.x of the http-signature node module are supported.
 *
 * - Token Auth (tokenAuth): using a token generated by keyapi. Be aware that
 *   token auth also requires HTTP Signature Auth for the caller, whereas the
 *   token is for the user the caller is calling on behalf of.
 *
 * Token auth is not recommended. While it works, and is in use by Joyent, it's
 * also messy and needs to be replaced.
 *
 * During the authentication process, there are several properties set to the
 * Restify `req` object:
 *
 * - req.caller: Always the sdcPerson object performing the request. It can be
 *   the main account for this request, a sub-user of such account or a
 *   different account, either the same user using a 3rd party application
 *   through token-auth (for example, a web UI), or even an administrative
 *   account performing any action instead of a given user.
 * - req.account: Despite of the value set for `req.caller`, this property will
 *   always be set to the account we're operating as, either if the caller is
 *   the account owner itself, an administrative account or a sub-user.
 * - req.subuser: Only set if the request is being performed by an account
 *   sub-user.
 * - req.username: the login value for `req.caller`, unless on the cases when
 *   a sub-user is performing the request. On such cases, it's set to
 *   `account.login`.
 * - req.subuser: subuser's uuid when present.
 */

var assert = require('assert-plus');
// obsolete http-signature 0.9.x
var httpSig09 = require('./node-http-signature');
// Modern http-signature
var httpSig = require('http-signature');
var restify = require('restify');
var semver = require('semver');
var tritonTracer = require('triton-tracer');
var vasync = require('vasync');
var jsprim = require('jsprim');

// --- Globals

var BadRequestError = restify.BadRequestError;
var InternalError = restify.InternalError;
var InvalidCredentialsError = restify.InvalidCredentialsError;
var InvalidCreds = restify.InvalidCredentialsError;
var NotAuthorizedError = restify.NotAuthorizedError;

var SIGN_ALGOS = {
    'RSA-SHA1': true,
    'RSA-SHA256': true,
    'RSA-SHA384': true,
    'RSA-SHA512': true,
    'DSA-SHA1': true,
    'DSA-SHA256': true,
    'ECDSA-SHA256': true,
    'ECDSA-SHA384': true,
    'ECDSA-SHA512': true
};

// --- Messages

var ACCOUNT_DISABLED = 'Account or user is disabled';
var BACKEND_ERR = 'Internal error occurred while validating account';
var DEF_401 = 'You must make authenticated requests to use CloudAPI';
var FORBIDDEN = 'You do not have permission to access %s';
var INVALID_AUTHZ = 'Invalid authorization header';
var INVALID_CREDS = 'Invalid authorization credentials supplied';
var INVALID_KEY = 'Invalid KeyId %s in authorization header';
var INVALID_ALGO = '%s is not a supported signing algorithm';
var INVALID_DEV = 'The token provided is not authorized for this application';



// --- Middleware


function setAccountInfo(req, account, subuser) {
    if (subuser) {
        req.caller = subuser;
        req.subuser = subuser.uuid;
    } else {
        req.caller = account;
    }

    req.account = account;
    req.username = account.login;
}

function ldapFilterEscape(str) {
    /* eslint-disable no-control-regex */
    return (str.replace(/[*()\\\x00]/g, function (ch) {
        var n = ch.charCodeAt(0).toString(16).toUpperCase();
        while (n.length < 2) {
            n = '0' + n;
        }
        return ('\\' + n);
    }));

    /* eslint-enable no-control-regex */
}

/*
 * Check whether the incoming HTTP request uses http-signature-auth
 * (https://tools.ietf.org/html/draft-cavage-http-signatures-03). If it does,
 * extract the key ID and hash from the Authentication header, verify the
 * signature is correct, then load from UFDS req.caller, req.username,
 * req.account, and possibly req.subuser if this request is for a subser.
 *
 * Almost all HTTP requests for version 7.0 and up must use
 * http-signature (verion 0.9 or later).
 */
function signatureAuth(req, res, next) {
    assert.ok(req.log);
    assert.ok(req.sdc);

    next = tritonTracer.cls().bind(next);

    var cls = tritonTracer.cls();
    var scheme = req.authorization.scheme || '';
    if (scheme.toLowerCase() !== 'signature') {
        return next();
    }

    var keyId;
    var log = req.log;
    var sig = req.authorization.signature;
    var ufds = req.sdc.ufds;

    var algorithm = req.authorization.signature.algorithm;

    if (SIGN_ALGOS[algorithm] !== true) {
        return next(new InvalidCreds(INVALID_ALGO, algorithm));
    }

    try {
        keyId = sig.keyId.split('/');
    } catch (e) {
        log.error('Error parsing authorization header: %s', e.stack);
        return next(new BadRequestError(INVALID_AUTHZ));
    }

    // keyId.length is 4 for main account users and 6 for sub-users,
    // given we do need to identify both, main account, and that the sub-user
    // key may have the same name than the main account key.
    // We'll take advantage of this to difference between main account user
    // and sub-users here
    var v = req.getVersion();
    var account, key, subuser;
    var login, keyID, sublogin;

    if (!keyId || keyId.length !== 4 || keyId[2] !== 'keys') {
        // Sub-users login starting with version 7.2.0:
        if (!(semver.satisfies('7.2.0', v) || semver.ltr('7.2.0', v))) {
            return next(new InvalidCreds(INVALID_KEY, sig.keyId));
        } else {
            if (!keyId || keyId.length !== 6 || keyId[4] !== 'keys') {
                return next(new InvalidCreds(INVALID_KEY, sig.keyId));
            } else {
                sublogin = keyId[3];
                keyID = keyId[5];
            }
        }
    } else {
        keyID = keyId[3];
    }

    login = keyId[1];

    function getAccount(_, cb) {
        cb = cls.bind(cb);
        ufds.getUser(login, cls.bind(function (err, u) {
            if (err) {
                if (err.restCode === 'ResourceNotFound') {
                    log.info('UFDS.getUser found no account');
                } else if (err.restCode === 'InternalError') {
                    // separate out InternalError so that we don't incorrectly
                    // report a user doesn't exist if there's a problem
                    // reaching the backend
                    log.trace({err: err}, 'UFDS.getUser error');
                    return cb(new InternalError(BACKEND_ERR));
                } else {
                    log.trace({err: err}, 'UFDS.getUser error');
                }

                return cb(new InvalidCreds(INVALID_CREDS));
            }
            account = u;
            return cb(null);
        }));
    }

    function getKey(_, cb) {
        cb = cls.bind(cb);
        var a = (subuser) ? account.uuid : null;
        var u = (subuser) ? subuser : account;
        var id = ldapFilterEscape(keyID);
        ufds.getKey(u, id, a, cls.bind(function (err, k) {
            if (err) {
                log.trace({err: err}, 'UFDS.getKey error');
                return cb(new InvalidCreds(INVALID_CREDS));
            }

            key = k;
            return cb(null);
        }));
    }

    function getSubUser(_, cb) {
        cb = cls.bind(cb);
        ufds.getUser(sublogin, account.uuid, cls.bind(function (err, u) {
            if (err) {
                if (err.restCode === 'ResourceNotFound') {
                    log.info('UFDS.getUser found no subuser');
                } else {
                    log.trace({err: err}, 'UFDS.getUser error');
                }

                return cb(new InvalidCreds(INVALID_CREDS));
            }
            subuser = u;
            return cb(null);
        }));
    }

    function verifySignature(_, cb) {
        cb = cls.bind(cb);
        log.debug({keyId: sig.keyId, pkcs: key.pkcs}, 'verifySignature');
        var signatureVerified = false;

        try {
            if (sig.is09) {
                signatureVerified = httpSig09.verifySignature(sig, key.pkcs);
            } else {
                signatureVerified = httpSig.verifySignature(sig, key.pkcs);
            }
        } catch (err) {
            log.error({err: err}, 'verifySignature: exception');
            return cb(new InvalidCreds(INVALID_CREDS));
        }

        if (!signatureVerified) {
            log.debug({sig: sig, key: key.standard}, 'verifySignature: FAIL');
            return cb(new InvalidCreds(INVALID_CREDS));
        }
        return cb(null);
    }

    var funcs = [getAccount];

    if (sublogin) {
        funcs.push(getSubUser);
    }

    return vasync.pipeline({
        funcs: funcs.concat([getKey, verifySignature])
    }, function (err, results) {
        if (err) {
            return next(err);
        }

        setAccountInfo(req, account, subuser);

        return next();
    });
}


/*
 * Checks whether this HTTP request is using token auth. The token is provided
 * by keyapi, and is used by third parties (or third applications) to make a
 * request to cloudapi on behalf of another user.
 *
 * Note that token auth depends on signature auth as well. The signature auth
 * is signed by the third-party application on the other side of the HTTP
 * request, using that application's own key and account details. The token
 * contains the details about the user or app on the other side of that
 * application, which the application is calling on behalf of.
 *
 * So a token request looks a bit like this header-wise:
 *
 * Authorization: Signature keyId="/<third-party account>/keys/<some third-
 *   party key>",algorithm="RSA-SHA256" <base64-encoded http-signature chunk>
 * X-Auth-Token: {"keyid":"<keyapi-generated UUID","data":"<base64 data about
 *   the user initiating this call>","version":"0.1.0","hash":
 *   "<base64 hash of data>"}
 */

function tokenAuth(req, res, next) {
    assert.ok(req.log);
    assert.ok(req.sdc);

    var scheme = req.authorization.scheme || '';
    // 'signature' is not a bug, since token auth also requires signature auth.
    // We differentiate normal signature auth and token auth by the presence of
    // a X-Auth-Token header.
    if (scheme.toLowerCase() !== 'signature') {
        return next();
    }

    var log = req.log;
    var sig = req.authorization.signature;
    var jsonToken = req.header('X-Auth-Token');

    if (!jsonToken) {
        return next();
    }

    function invalidCreds() {
        next(new InvalidCredentialsError(INVALID_DEV));
    }

    function setCreds(err, obj) {
        if (err) {
            log.error({ err: err }, 'keyapi error');
            return invalidCreds();
        }

        if (obj.expires) {
            var expires = new Date(obj.expires);
            var now = new Date();

            if (now > expires) {
                return invalidCreds();
            }
        }

        if (obj.devkeyId !== sig.keyId) {
            return invalidCreds();
        }

        if (!obj.permissions.cloudapi) {
            return invalidCreds();
        }

        var perms = obj.permissions.cloudapi;
        var authorized = false;

        for (var i = 0; i < perms.length; i += 1) {
            var currPerm = perms[i].split('/*');
            var currPermUrl = currPerm[0];
            var pathname = req.getUrl().pathname;

            if (currPermUrl === pathname) {
                authorized = true;
                break;
            }

            if (pathname.search(currPermUrl) === 0 &&
                currPerm.length === 2 &&
                pathname.charAt(currPermUrl.length) === '/') {
                authorized = true;
                break;
            }
        }

        if (!authorized) {
            return invalidCreds();
        }

        var account = obj.account;
        if (!obj.subuser) {
            setAccountInfo(req, account);
            return next();
        }

        return req.sdc.ufds.getUser(obj.subuser.login, account.uuid,
        function (er2, subuser) {
            if (er2) {
                log.error({ err: er2 }, 'error loading subuser');
                return invalidCreds();
            }
            setAccountInfo(req, account, subuser);
            return next();
        });
    }

    try {
        var token = JSON.parse(jsonToken);
        return req.sdc.keyapi.detoken(token, setCreds);
    } catch (e) {
        log.error('Error calling keyapi: ' + e.stack);
        return next(new InvalidCredentialsError(INVALID_CREDS));
    }
}


function assertAuthenticated(req, res, next) {
    if (req.getUrl().pathname === '/--ping') {
        return next();
    }

    var caller = req.caller;
    var account = req.account;

    if (typeof (caller) !== 'object' || typeof (account) !== 'object') {
        return next(new InvalidCredentialsError(DEF_401));
    }

    if (caller.disabled === 'true' || account.disabled === 'true') {
        return next(new NotAuthorizedError(ACCOUNT_DISABLED));
    }

    return next();
}


function loadAccount(req, res, next) {
    if (req.getUrl().pathname === '/--ping') {
        return next();
    }

    assert.ok(req.sdc);

    var log = req.log;
    var ufds = req.sdc.ufds;

    if (req.params.account === 'my') {
        if (req.subuser) {
            req.params.account = req.account.login;
        } else {
            req.params.account = req.caller.login;
        }
    }
    req.params.account = decodeURIComponent(req.params.account);

    if (req.subuser && !req.header('X-Auth-Token')) {
        // Account already set during signature auth, no need to re-do:
        log.debug({account: req.account}, 'account already loaded');
        return next();
    }

    // PUBAPI-780: If request is made by the user itself, using no token-auth
    // we can safely skip account re-loading.
    if (req.username === req.params.account && !req.header('X-Auth-Token')) {
        log.debug('account %j already loaded', req.caller);
        req.account = req.caller;
        return next();
    }

    return ufds.getUser(req.params.account, function (err, customer) {
        if (err) {
            log.error({err: err}, 'UFDS.getUser error');
            return next(err);
        }

        log.debug('loaded account %j', customer);
        req.account = customer;
        return next();
    });
}


/**
 * Deny access if the account.allowed_dcs doesn't include this DC.
 * This middleware is only added if `config.account_allowed_dcs` is true.
 */
function authnAllowedDcs(req, res, next) {
    if (req.getUrl().pathname === '/--ping') {
        next();
        return;
    }

    var datacenterName = req.config.datacenter_name;
    var allowed_dcs = req.account.allowed_dcs;
    if (!allowed_dcs ||
        (Array.isArray(allowed_dcs)
            ? allowed_dcs.indexOf(datacenterName) === -1
            : allowed_dcs !== datacenterName)) {
        var forbiddenMsg = 'Forbidden';
        if (req.config.account_allowed_dcs_msg) {
            forbiddenMsg += ' (' + req.config.account_allowed_dcs_msg + ')';
        }
        next(new NotAuthorizedError(forbiddenMsg));
        return;
    }

    next();
}


// PUBAPI-834: sdcAccountRole/policy authorization for sdcAccountUsers
// takes place here.
function authorize(req, res, next) {
    if (req.getUrl().pathname === '/--ping') {
        return next();
    }

    var account = req.account;
    var caller = req.caller;
    var mahi = req.sdc.mahi;
    var groups = [];

    assert.ok(account);
    assert.ok(caller);

    /* An account operating on itself is always allowed. */
    if (account.uuid === caller.uuid) {
        return next();
    }

    if (typeof (caller.groups) === 'function') {
        groups = caller.groups();
    }

    /*
     * Members of role-operators are *only* operators when they provide the
     * as-role header -- this is true even if they are also members of the
     * regular operators group (isAdmin).
     */
    if (groups.indexOf('role-operators') !== -1) {
        if (req.params['as-role'] === '_operator') {
            return next();
        }
    } else if (typeof (caller.isAdmin) !== 'function' || caller.isAdmin()) {
        /*
         * Some tests and plugins depend on us calling isAdmin() specifically
         * here to detect operators, *not* looking in groups.
         */
        return next();
    }

    var activeRoles;
    function getRoles(_, cb) {
        var asRoleParam = req.params['as-role'];
        var requestedRoles = asRoleParam && asRoleParam.split(',');

        // If the caller provided a list of roles to operate on a resource as,
        // we look them up and set them as the activeRoles. If the caller did
        // not, we load the user's default roles as activeRoles for this
        // operation instead.
        if (requestedRoles && requestedRoles.length) {
            caller.rolesOnAccount(account.uuid, function (err, roles) {
                if (err) {
                    return cb(err);
                }

                var roleLookup = {};
                roles.forEach(function (r) { roleLookup[r.name] = r; });

                activeRoles = [];
                for (var i = 0; i !== requestedRoles.length; i++) {
                    var role = roleLookup[requestedRoles[i]];

                    if (role) {
                        activeRoles.push(role);
                    } else {
                        var msg = '"' + role + '" not listed in user roles';
                        return cb(new Error(msg));
                    }
                }

                return cb();
            });
        } else {
            caller.defaultRolesOnAccount(account.uuid,
                function (err, defaultRoles) {
                if (err) {
                    return cb(err);
                }

                activeRoles = defaultRoles;

                return cb();
            });
        }
    }

    var info;
    function getUser(_, cb) {
        if (req.subuser) {
            mahi.getUser(caller.login, account.login, function (err, _info) {
                if (err) {
                    return cb(err);
                }

                info = _info;

                return cb();
            });
        } else {
            mahi.getAccount(caller.login, function (err, _info) {
                if (err) {
                    return cb(err);
                }

                info = _info;

                return cb();
            });
        }
    }

    var owner;
    function getAccount(_, cb) {
        mahi.getAccount(account.login, function (err, _owner) {
            if (err) {
                return cb(err);
            }

            owner = _owner;

            return cb();
        });
    }

    return vasync.pipeline({
        funcs: [getRoles, getUser, getAccount]
    }, function (err) {
        if (err) {
            return next(new NotAuthorizedError(FORBIDDEN, account.login));
        }

        var authOpts = {
            typeTable: req.config.apertureConfig.typeTable,
            principal: info,
            action: req.routename,
            resource: {
                key: req.path(),
                owner: owner
            },
            conditions: {
                date: new Date(req._time),
                day: new Date(req._time),
                time: new Date(req._time),
                'user-agent': req.headers['user-agent'],
                sourceip: req.connection._xff,
                method: req.method.toLowerCase(),
                activeRoles: activeRoles.map(function (r) { return (r.uuid); }),
                datacenter: req.config.datacenter_name
            }
        };

        // PENDING: Need to review if we can go ahead with just a single IP
        // argument or may need to difference between IPs by nic tag (private,
        // public, ...).
        if (req.machine && req.machine.ips) {
            authOpts.conditions.ip = req.machine.ips;
        }

        // It is important to document that in order to use tags in policy
        // rules, the "::string" type name must be appended to the tag name:
        // `tag_$tagName::string=$tagValue`:
        if (req.machine && req.machine.tags) {
            var tags = req.machine.tags;

            Object.keys(tags).forEach(function (t) {
                authOpts.conditions['tag_' + t] = tags[t];
            });
        }

        if (req.resource.roles && req.resource.roles.length) {
            authOpts.resource.roles = req.resource.roles.map(function (r) {
                return (r.uuid);
            });
        } else {
            authOpts.resource.roles = [];
        }

        var authorized, details;
        try {
            authorized = mahi.authorize(authOpts);
        } catch (_e) {
            details = authOpts.resource.key + ' (' + authOpts.action + ')';
            return next(new NotAuthorizedError(FORBIDDEN, details));
        }

        // In theory mahi should raise an exception if the user is not
        // authorized. Just in case:
        if (!authorized) {
            details = authOpts.resource.key + ' (' + authOpts.action + ')';
            return next(new NotAuthorizedError(FORBIDDEN, details));
        }

        // We may need this for later use if we are creating new resources and
        // the sub-user didn't specify any role.tag:
        req.activeRoles = activeRoles;

        return next();
    });
}


function preSignedUrl(req, res, next) {
    var expires;
    var log = req.log;
    var q = req.query;
    /* JSSTYLED */
    var methods = (q.method || req.method).split(/\s*,\s*/);
    var now = Math.floor(Date.now() / 1000);

    methods.sort();

    log.debug({methods: methods}, 'preSignedUrl: entered');

    if (methods.indexOf(req.method) === -1) {
        next(new Error(req.method + ' was not a signed method'));
        return;
    }

    /* All of these are required fields for this to be a valid presigned URL. */
    var required = [
        'algorithm',
        'expires',
        'keyId',
        'signature'
    ];

    var missing = required.filter(function isMissing(k) {
        return (!q[k]);
    });

    /*
     * If we're missing _all_ of the required fields, assume this isn't a pre-
     * signed URL and continue processing.
     *
     * If we're missing some of the fields but have at least 1, then assume the
     * user meant to supply a pre-signed URL but some fields are missing. This
     * is an error.
     */
    if (missing.length === required.length) {
        next();
        return;
    } else if (missing.length > 0) {
        next(new Error('parameters "' + missing.join(', ') + '" are required'));
        return;
    }

    expires = jsprim.parseInteger(q.expires, { allowSign: false });
    if (typeof (expires) !== 'number') {
        log.debug(expires, 'error parsing "expires" in pre-signed URL');
        next(new Error('expires is invalid'));
        return;
    }

    log.debug({
        expires: expires,
        now: now
    }, 'checking if request is expired');
    if (now > expires) {
        next(new Error('request expired'));
        return;
    }

    var parsed = {
        scheme: 'Signature',
        algorithm: q.algorithm.toUpperCase(),
        keyId: q.keyId,
        params: {
            keyId: q.keyId,
            signature: q.signature,
            role: q.role,
            'role-tag': q['role-tag']
        },
        signature: q.signature,
        signingString: ''
    };

    // Build the signing string, which is:
    // METHOD\n
    // $value_of_host_header
    // REQUEST_URL\n
    // key=val&...
    // with sorted query params (lexicographically),
    // minus the actual signature.
    parsed.signingString =
        methods.join(',') + '\n' +
        req.header('host') + '\n' +
        req.path() + '\n' +
        Object.keys(q).sort(function sortQueryParams(a, b) {
            return (a.localeCompare(b));
        }).filter(function isNotSignature(k) {
            return (k.toLowerCase() !== 'signature');
        }).map(function convertToRFC3986(k) {
            return (rfc3986(k) + '=' + rfc3986(q[k]));
        }).join('&');

    log.debug({signatureOptions: parsed}, 'preSignedUrl: parsed');

    if (SIGN_ALGOS[parsed.algorithm] !== true) {
        next(new Error(parsed.algorithm + ' is not a supported signing ' +
            'algorithm'));
        return;
    }

    req.authorization = {
        role: q.role || '',
        'role-tag': q['role-tag'] || '',
        callerKey: q.keyId,
        scheme: parsed.scheme,
        signature: parsed
    };

    log.debug({auth: req.auth}, 'preSignedUrl: done');
    next();
}

function rfc3986(str) {
    /* JSSTYLED */
    return (encodeURIComponent(str)
            /* JSSTYLED */
            .replace(/[!'()]/g, escape)
            /* JSSTYLED */
            .replace(/\*/g, '%2A'));
}


// --- Exports

module.exports = {
    signatureAuth: signatureAuth,
    tokenAuth: tokenAuth,
    assertAuthenticated: assertAuthenticated,
    loadAccount: loadAccount,
    authnAllowedDcs: authnAllowedDcs,
    authorize: authorize,
    preSignedUrl: preSignedUrl
};
